# CLAUDE.md

## Project
モンスター対戦アプリ - 読み合い特化の1vs1バトルゲーム（Web）

## Tech Stack
- Frontend: Phaser.js + TypeScript
- Backend: Node.js + Socket.io + TypeScript
- Hosting: Vercel（フロント）/ Render（バック）
- Storage: LocalStorage（ゲーム進捗保存）

## Key Commands
```bash
# よく使うコマンドを記載
npm start          # 開発サーバー起動
npm run build      # ビルド
npm run test       # テスト実行
npm run lint       # リンター実行
```

## Project Structure
```
src/
├── scenes/       # Phaserシーン（タイトル、バトル、リザルト等）
├── entities/     # モンスター、装備等のゲームオブジェクト
├── battle/       # バトルロジック（ダメージ計算、AI等）
├── network/      # Socket.io通信
├── types/        # 型定義
├── utils/        # ユーティリティ
└── constants/    # 定数（パラメータ、魂格データ等）
```

## Important Files
- `docs/PROJECT.md` - プロジェクト仕様書（ゲーム設計の全詳細）

## Domain Terms
- **魂格（コンカク）**: モンスターの種カテゴリ（全8種）
- **TCB（ツインコマンドバトル）**: 毎ターン2コマンド同時実行の戦闘方式
- **スタンス**: 通常/攻勢/守勢の3段階切替（攻防バランスを変化）
- **リフレクター**: 特殊攻撃を反射/無効化する防御装備
- **導き手**: プレイヤーの世界観上の呼称

## Guidelines
- 不明点は確認してから実装
- 既存のコードスタイルを尊重
- **テスト駆動開発（TDD）を採用**

---

## Development Workflow（TDD）

各タスクは以下のステップで進める。

### STEP 1-2: 探索 + 計画（Planエージェント）

| 内容 | 詳細 |
|------|------|
| 関連ファイル調査 | 既存コード、型定義、テストの確認 |
| テスト設計 | テストケースの洗い出し（正常系・異常系・境界値） |
| 実装方針策定 | インターフェース設計、依存関係の整理 |

**計画に含めるべき内容:**
- テストファイルのパス
- テストケース一覧（describe/it構造）
- 実装ファイルのパス
- 関数シグネチャ（入出力の型）

### STEP 3: 実装（TDDサイクル）

```
┌─────────────────────────────────────────────────────┐
│  3-1. テストを書く                                    │
│       期待する動作を明確にする                         │
│       ↓                                              │
│  3-2. テストの失敗を確認                              │
│       npm test でテストが失敗することを確認            │
│       ↓                                              │
│  3-3. テストをコミット                                │
│       テストの内容を固定（実装前にコミット）            │
│       ↓                                              │
│  3-4. 実装を書く                                      │
│       テストが通るように実装を作成                     │
│       ⚠️ テストコードは変更しない                      │
│       ↓                                              │
│  3-5. 実装をコミット                                  │
│       完成したコードを保存                            │
└─────────────────────────────────────────────────────┘
```

### STEP 4: 実装検証（独立サブエージェント）

テストがすべて通ったら、**独立したサブエージェント**で以下を検証:

| 検証項目 | 内容 |
|----------|------|
| テスト依存性 | テストに過度に依存した実装になっていないか |
| エッジケース | テストでカバーされていないケースはないか |
| コード品質 | 可読性、保守性、パフォーマンスの観点 |
| 設計原則 | SOLID原則、DRY原則への準拠 |

### STEP 5: PR作成・マージ（Bashエージェント）

| 内容 | 詳細 |
|------|------|
| 型チェック | `npx tsc --noEmit` |
| 全テスト実行 | `npm test` |
| PR作成 | テストと実装の両方を含むPR |
| マージ | レビュー後にマージ |

---

## TDDのルール

1. **Red → Green → Refactor**
   - Red: 失敗するテストを書く
   - Green: テストが通る最小限の実装
   - Refactor: コードを改善（テストは変更しない）

2. **テストファースト**
   - 実装前に必ずテストを書く
   - テストが仕様書の役割を果たす

3. **テストコードの不変性**
   - 実装フェーズでテストコードを変更しない
   - テストが間違っていた場合は新しいサイクルで修正

4. **小さなステップ**
   - 一度に1つの機能をテスト→実装
   - 複雑な機能は分割して段階的に実装

---

## サブエージェント一覧

| エージェント | 用途 |
|-------------|------|
| **Plan** | コードベース探索 + 実装計画 + テスト設計 |
| **Explore** | コードベース探索（調査のみ） |
| **Bash** | git操作、コマンド実行 |
| **general-purpose** | 実装検証、複雑なマルチステップタスク |
| **spec-checker** | PROJECT.mdの仕様と実装の整合性を検証 |
| **battle-logic-reviewer** | バトルロジック（ダメージ計算、AI等）の実装を検証 |
| **test-designer** | テストケースの設計とレビュー |

---

## スキル（カスタムコマンド）

| コマンド | 用途 |
|---------|------|
| **/tdd** | TDDサイクルを実行（テスト設計→テスト作成→実装→検証） |

---

## テストファイル命名規則

```
src/__tests__/
├── {機能名}.test.ts      # サービス・ユーティリティのテスト
├── {コンポーネント名}.test.tsx  # コンポーネントのテスト
└── integration/          # 統合テスト
```

## コミットメッセージ規則

```
test: {機能名}のテストを追加
feat: {機能名}を実装
fix: {バグ内容}を修正
refactor: {対象}をリファクタリング
```
